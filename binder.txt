1. 什么是虚拟地址
虚拟地址是新规定与屋里地址而言的,每一个程序在被启动的时候都会创建进程对应的虚拟地址,操作系统只是将程序的一部分加载到屋里内存中,将


1. binder是做什么的
binder是Android中重要的进程间通讯的一种方式,通过binder进行进程间通讯只需要一次数据拷贝,而其他无论进程间通讯例如socket需要至少两次数据拷贝
2. 为什么binder只需要一次数据拷贝
例如process a读取文件普通的读取需要两次
	1. 将位于物理内存中的数据读取到内核空间的缓冲区
	2. 将内核空间的数据缓冲的数据拷贝到用户空间完成文件的读取
	
而binder由于底层实现使用的是mmap,mmap将内核空间的数据缓冲区和接收方的用户空间的地址和真实的物理内存进行映射,这样当发送方将数据从用户空间拷贝到内核空间的时候
接收进程也就能同时接收到数据了

什么是用户空间什么是内核空间
用户空间是指应用运行的空间,应用运行的空间以4G的内存为例计算其1/4为内核空间3/4为用户空间 可用的


在我看来无论是用户空间还是内核空间都是存在于虚拟内存当中,而应用程序在运行的时候使用的其实都是虚拟内存地址,虚拟地址通过MMU内存管理单元转换变成物理地址
MMU转换

计算机是如何找到真实的物理地址的
首先程序使用的都是虚拟地址
每个进程都会维护一个TLB,TLB维护了虚拟地址和真实地址的映射关系
TLB有三层和4层的
比如



而虚拟内存是相对于物理内存而言的,物理内存一般而言指我们的内存条等平常大家可以感知的内存

程序的成员变量的地址是指向虚拟内存中的虚拟地址的,虚拟地址通过MMU,TLB 转换成物理地址 


为什么要有虚拟地址,虚拟地址解决什么问题
通过CPU实现的虚拟内存可以让程序自身感觉到自己拥有整个内存空间
虚拟内存可以远大于物理内存,程序的运行是有时间和空间的局部性的,也就是说程序在运行的耨一个时间点其所使用的数据基本都集中在一块,那么就可以将程序进行分段加载到内存中运行
使得较小的内存空间可以运行较大的程序
当物理内存用完之后会出现什么情况,当物理内存用完之后继续申请屋里内存的时候会将屋里内存中不用的数据换出到硬盘,当使用完毕之后再将之前换出的内存换入,从而在一定程度上增加了
总的可使用的内存,让内存较小的机器运行较大的程序
同时由于虚拟内存的存在防止了程序直接访问物理内存,也就避免了PA操作PB的内存空间从而导致整个系统出现问题的可能


cache 是在CPU内部的 例如典型的英特尔的CPU的三级缓存
cache 是真实存在的所以cache是属于物理内存的,之前我们说到cache是告诉缓存其L1的读写速度大概在3-4个CPU周期,所以CPU在通过MMU寻址的时候其实是先向Cache中寻找是否存在对应的
屋里地址的,如果没有则向L2的Cache直至找到真实的物理地址,那么由于Cache的存在其实我们还会遇到一个什么问题,cache的缓存一致性
如何解决cache的缓存一致性问题的,就涉及到了另外一个协议MESI 缓存一致性协议,所谓的MESI缓存一致性协议简单的讲就是当
T_A 和 T_B同时操作一个数据C的时候这个时候C处于合法状态,但是一旦有TA或者TB更改了这个数据之后C将会被置位I状态,此时所有的线程在再次使用C的时候会发现C已经是非法状态,则会重新
向主内存读取数据,也就解决了缓存一致性的问题,而这个其实就是对应于java的上层的volatile 关键字



虚拟内存和物理内存
什么是虚拟内存
虚拟内存是CPU维护的一个逻辑内存,所有的应用程序都是运行在虚拟内存中的,而虚拟内存的大小是由CPU地址长度决定的,比如48位的CPU地址长度能够产生的虚拟地址的大小是0-2^36个虚拟地址
(36VPN + 12 VPO)
那么我们可以用hashmap来存储Vp和PP的映射关系,但是这样的话使用的内存空间就是2^36,这是无法实现的,所需要的内存实在是太大
所以出现了page,也就是将内存空间划分成一个个4Kb的大小
每个page现在一般而言是4Kb
完全来映射48位的CPU地址的虚拟内存需要2^24的大小,其实这也是非常大的
进而出现了多级page缓存
即将48位中前36位的VPN分成4份(9位2^9 = 512),这样我们就获得一个4级的page,而每级page 拥有512个item,进而形成一个512叉树,这样我们就可以用极少量的内存来映射整个虚拟地址和屋里内存
但是仍然存在一个问题,在最坏的情况下我们仍然要是用2^9*2*9*2*9*2*9 = 2^36的内存空间,但是这种情况一般而言是不会发生的
原因是在于我们的内存地址的结构heap 是向内存高位移动,stack是向内存低位移动,也就是说在heap和stack之间是存在大量没有使用的内存空间的,而没有使用的内存空间我们是不会
给其创建page表的,如此一来我们就大量的节省了内存

由于堆是向高位移动,栈是向低位移动的,那么GC是什么样的
ART虚拟机使用的标记回收算法 mark -sweep
并在标记回收上使用了更为细致的
在内存的分配上有zygote space 





