JVM运行时图
一. JVM运行时图分两大块
第一块是所有线程共享的,包含方法区/常量池/堆
1. 对于方法区其实在ART 虚拟机严格来说并不存在,在代码编译的过程生成apk的过程中,会生成dex文件,dex文件在art虚拟机安装apk的过程中会被预编译成机器码,存储在ELF文件中,在ART虚拟机加载程序的过程中
会将ELF加载到code cache中,而方法区就在这个时候被CPU从ELF加载到内存中,所以可以理解为code cache是包含Hotspot的方法区的
2. 对于常量池而言在jvm规范中是存在于方法区的,在上述的描述中我们可以知道其实常量池是方法区的一部分的,所以art虚拟机中,常量池也是存储在code cache中的,在编译的时候就已经确定了
常量池的内容,在安装apk的过程中会从apk中解析出dex文件,并将dex最终解码成机器码存储在ELF中,再加载到内存中code cache中,所以常量池存在于code cache中.
3, 堆
	new出来的对象实际上是存储在堆中,当new一个对象的时候在堆中开辟一块内存地址存储对象的实际内容,而对象的引用地址实际存储在栈中,在栈中使用对象的时候首先通过对象的引用地址
	通过内存映射的方式找到对象在堆中的实际位置,这个地址实际上是对象的起始地址,之后再通过MMU转换到真实的物理地址
二.JVM的线程私有的内存空间
栈内存是各个线程私有的内存空间
栈的内存结构如下
1. 栈主要包括 farme /pc register 而farme又包括 操作数栈,类的常量池引用,局部变量数组,方法执行的过程实际上是栈的调用过程,每一个方法都相当于第一个栈,当方法执行完毕后弹栈
当所有的栈帧弹出后整体方法执行完毕,每个方法的执行相当于一个栈帧,每个栈帧都有常量池的引用,但是常量池一个类只有一个,只是栈帧中常量池的引用指向类的常量池

Volatile的具体实现
	volatile是java中的一个非常关键的关键字,其作用是保证了被修饰内容的可见性和有序性,所谓的可见性是基于多线程的基础上每个线程对其他线程中的内容不可见的而引入的.
	例如ThreadA中的a =0 对于ThreadB中是不可见的,即在ThreadA中将a= 1,对于ThreadBare而言a仍然是为0,volatile的作用就是在ThreadA修改了a=1之后在ThreadB中使用时发现ThreadB中的a
	由于EMSI规则已经被标记为I了所以会重新从内存中获取a的值,此时a的值在ThreadB中就被正确的修改成了1了
	所谓的有序性是指在编译优化的过程中虚拟机会在保证程序能返回正确的结果的前提下重新对指令进行排序,从而提高程序运行的效率,而volatile修饰的内容就保证了这个有序性,被volatile修饰的内容不会被编译器优化
	
	在我的工作当中印象最深刻的一次是我们存在一个文件,文件中描述的是一个3D车模的各个点,在程序加载的时候需要先将各个点读取出来然后做各种运算,当时我是把所有的点取出后放在一个For循环中
	进行了加法和乘法运算,但是这个效率特别的低,整个加载过程要将近两秒,这个时间对于一个车载的程序而言是比较长的,所以对这个算法进行了优化,将所有的点取出后分别用两个for循环做加法和乘法运算
	这样优化之后整个加载速度提升到了毫秒级,这也是我第一次感受到编译器优化的威力
	
	volatile是怎么保持可见性的
		volatile修饰的内容 a 首先会读取主内存的值到工作空间中,此时工作空间中存在主内存对于a的拷贝,此时如果其他线程B更改了