binder机制
常见的IPC机制
管道(半双工) ,信号量(kill -9),共享内存,文件,socket,message消息队列
Android中的IPC机制
aidl,provider,message,序列化,bundle,文件共享
内核空间和用户空间
内核空间工内核使用的,在内核空间中数据是可以进程间共享的,用户空间是通用app运行的空间,是无法访问内核空间的,如果需要访问内核空间就需要系统调用,这就涉及到上下文的切换,而上下文的切换是一件很费时间的操作 
binder 是Android中重要的IPC机制,其基本实现原理是通过memory map实现的,对于mmap而言app从硬盘读取数据仅需要一次拷贝,首选mmap在内核空间创建一个一块内存区域(进程虚拟内存区),由于mmap最大支持4M,而Android限制其最大为1M,故而这也是为何Android跨进程传递数据最大只支持<1M 的根本原因,将文件和虚拟内存区建立映射关系,此时app读取文件只需要通过copy_to_user即可读取文件
对于binder的进程间通信
在Linux中的进程间通讯流程
1. A将数据通过copy_from_user拷贝到进程的内核空间,
2. AB进程间的内核空间建立内存映射关系,
3. B的内核空间和B的用户空间建立映射关系

这样数就从A进程发送到B进程了

Android使用binder通讯的原因
1. 从性能上讲无论是socket还是共享文件等都需要多次的数据拷贝,性能较低,而共享内存性能最优,但是其操作较为复杂而且存在死锁的风险,binder在进程间通信的过程中只会拷贝一次数据,只比共享内存性能低
2. 从架构上来讲binder是可以通过系统的uid来确认调用者身份,从而保证了安全性,从模式上来讲使用的是cs模式,这种模式非常成熟,

当然Android系统中并不是所有地方的进程间通信都是采用的binder通信的方式,例如ams和zygote进程采用的是socket通信,kill process采用的是信号的方式

说道binder就必须要说Android的系统启动流程
首先init进程加载init.rc文件,通过inti.rc文件中的配置找到位于/system/bin下的app_process二进制文件,这个 文件就是zygote进程的二进制代码其程序入口为main方法,所有的zygote的子进程都是通过fork的形式创建的,而zygote进程在创建的时候会创建art虚拟机的实例,所以art虚拟机在

bind是在什么时候创建的呢
所有的进程都会在创建的时候创建一个processstate,在porcessstate.self方法中通过open_diver打开binder驱动,然后通过mmap在内核虚拟地址空间申请一个和用户虚拟内存相同大小的内存空间,并且申请屋里内存,然后将屋里内存分别映射到内核虚拟地址空间和用户虚拟内存中,这样内核空间和用户空间的内存映射关系就完成了








